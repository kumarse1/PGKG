import streamlit as st
import pandas as pd
import networkx as nx
from pyvis.network import Network
import psycopg2
import requests
from requests.auth import HTTPBasicAuth

# LLM Configuration
LLM_API_URL = "https://your-llm-endpoint.com/v1/chat/completions"
LLM_USERNAME = "your_username_here"
LLM_PASSWORD = "your_password_here"

# Database Connection
@st.cache_resource
def get_connection():
    db_user = ""
    db_password = ""
    db_host = ""
    db_port = ""
    db_name = ""
    
    return psycopg2.connect(
        dbname=db_name, user=db_user, password=db_password, host=db_host, port=db_port
    )

@st.cache_data
def load_data():
    conn = get_connection()
    nodes = pd.read_sql("SELECT * FROM kg_nodes", conn)
    edges = pd.read_sql("SELECT * FROM kg_edges", conn)
    return nodes, edges

def build_subgraph(nodes_df, edges_df, selected_node_id, direction):
    G = nx.DiGraph()
    
    center = nodes_df[nodes_df.node_id == selected_node_id].iloc[0]
    G.add_node(center.node_id, label=str(center.label), title=f"{center['name']}")
    
    if direction in ("All", "Outgoing", "Both"):
        out_edges = edges_df[edges_df.source_node_id == selected_node_id]
        for _, row in out_edges.iterrows():
            target = nodes_df[nodes_df.node_id == row.target_node_id]
            if not target.empty:
                tgt = target.iloc[0]
                G.add_node(tgt.node_id, label=str(tgt.label), title=f"{tgt['name']}")
                G.add_edge(center.node_id, tgt.node_id, label=str(row.relation_type))

    if direction in ("All", "Incoming", "Both"):
        in_edges = edges_df[edges_df.target_node_id == selected_node_id]
        for _, row in in_edges.iterrows():
            source = nodes_df[nodes_df.node_id == row.source_node_id]
            if not source.empty:
                src = source.iloc[0]
                G.add_node(src.node_id, label=str(src.label), title=f"{src['name']}")
                G.add_edge(src.node_id, center.node_id, label=str(row.relation_type))

    return G

def create_network_viz(G):
    net = Network(height="500px", width="100%", directed=True)
    net.from_nx(G)
    net.force_atlas_2based()
    
    html_path = "graph.html"
    net.save_graph(html_path)
    return html_path

def query_llm(question, context_data):
    try:
        context_text = f"""
        Knowledge Graph Context:
        - Selected Node: {context_data['selected_node']}
        - Connected Nodes: {context_data['connected_nodes']}
        - Total Nodes: {context_data['total_nodes']}
        - Total Edges: {context_data['total_edges']}
        
        Question: {question}
        """
        
        payload = {"messages": [{"role": "user", "content": context_text}]}
        
        response = requests.post(
            LLM_API_URL,
            json=payload,
            auth=HTTPBasicAuth(LLM_USERNAME, LLM_PASSWORD),
            headers={"Content-Type": "application/json"},
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            return result.get("choices", [{}])[0].get("message", {}).get("content", "No response")
        else:
            return f"Error: {response.status_code}"
        
    except Exception as e:
        return f"Failed: {str(e)}"

def main():
    st.set_page_config(page_title="Knowledge Graph", layout="wide")
    st.title("Knowledge Graph Explorer")
    
    # Load data
    nodes_df, edges_df = load_data()
    
    # Sidebar
    with st.sidebar:
        st.header("Controls")
        
        # Node selection
        node_options = sorted(nodes_df["name"].unique())
        selected_name = st.selectbox("Select Node:", node_options)
        selected_node = nodes_df[nodes_df["name"] == selected_name].iloc[0]
        selected_node_id = selected_node.node_id
        
        # Direction filter
        direction = st.selectbox("Direction:", ["All", "Outgoing", "Incoming", "Both"])
        
        # Stats
        st.metric("Nodes", len(nodes_df))
        st.metric("Edges", len(edges_df))
    
    # Main content
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader(f"Network: {selected_name}")
        subgraph = build_subgraph(nodes_df, edges_df, selected_node_id, direction)
        
        if len(subgraph.nodes()) > 0:
            html_file = create_network_viz(subgraph)
            with open(html_file, "r", encoding="utf-8") as f:
                html_content = f.read()
            st.components.v1.html(html_content, height=520)
        else:
            st.info("No connections found.")
    
    with col2:
        st.subheader("Node Details")
        st.write(f"**Name:** {selected_node['name']}")
        st.write(f"**Label:** {selected_node.label}")
    
    # Chat
    st.markdown("---")
    st.subheader("Chat")
    
    if 'chat_history' not in st.session_state:
        st.session_state.chat_history = []
    
    if st.button("Clear Chat"):
        st.session_state.chat_history = []
        st.rerun()
    
    # Display chat
    for role, message in st.session_state.chat_history:
        if role == "user":
            st.markdown(f"**You:** {message}")
        else:
            st.markdown(f"**AI:** {message}")
    
    # Chat input
    with st.form("chat_form", clear_on_submit=True):
        question = st.text_input("Ask a question:")
        submitted = st.form_submit_button("Send")
        
        if submitted and question.strip():
            st.session_state.chat_history.append(("user", question))
            
            context_data = {
                "selected_node": selected_name,
                "connected_nodes": len(subgraph.nodes()) - 1,
                "total_nodes": len(nodes_df),
                "total_edges": len(edges_df)
            }
            
            response = query_llm(question, context_data)
            st.session_state.chat_history.append(("ai", response))
            st.rerun()

if __name__ == "__main__":
    main()
